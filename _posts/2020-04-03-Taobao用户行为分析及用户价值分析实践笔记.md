---
layout:     post
title:      Taobao用户行为分析及用户价值项目分析笔记
subtitle:   花了两天时间，终于完成这个项目啦～
date:       2020-04-03
author:     terese
header-img: img/post-1.jpg
catalog:   true
tags:
    - 项目笔记
    - 数据分析实践
---

# 淘宝用户行为分析实践笔记记录

终于完成了这个分析项目了 ![[嘻嘻]](https://img.t.sinajs.cn/t4/appstyle/expression/ext/normal/33/2018new_xixi_org.png)实践太重要了，在实践中攻克一个个困难，最后完成整个项目的分析，能够找到兴趣所在，这是我最大的收获了吧。 以下是我记录实践中遇到的问题、解决方法以及笔记：

## 1.  pandas操作熟悉

1)修改列名

`df.columns = ['A','B']`

2) 查看列为空的值

#查看revenue为空的值
`df.loc[df['revenue'].isnull()]`

3) pandas找到和移除重复行

duplicated()方法：找到重复记录

- 查看列是否重复

```python
df['col_name'].duplicated()
```

- 查看整行是否重复

```python
df.duplicated()
```

- 查看subset是否重复

```python
df.duplicated(subset = [])
```

drop_duplicats()方法：删除重复记录

```css
df.drop_duplicats()
```

参数keep
 keep可以为first和last，表示是选择最前一项还是最后一项保留。

```bash
df.duplicated(keep = "first")
df.duplicated(keep = "last")
```

也可以设置布尔类型，当设为False时候，重复项将都被显示。

```bash
dataframe.duplicated(keep = "False")
```

4) python将时间戳转换为时间

datetime是Python处理日期和时间的标准库。如果需要将time_stamp这列转换为正常的时间形式，由于转换后的时间比北京时间慢8个小时，这里加上8个小时。

```python
import datetime
df['time_stamp'] = pd.to_datetime(df['time_stamp'],unit='s') +datetime.timedelta(hours=8)
```

参考：[python常用内建模块](https://github.com/github16cp/Python/blob/master/learningNotes/12_Common_Built-in_Modules.md)（Python处理日期和时间的标准库介绍，很详细！）

timestamp转换为datetime

要把`timestamp`转换为`datetime`，使用`datetime`提供的`fromtimestamp()`方法：

```
>>> from datetime import datetime
>>> t = 1429417200.0
>>> print(datetime.fromtimestamp(t))
2015-04-19 12:20:00
```

注意到timestamp是一个浮点数，它没有时区的概念，而datetime是有时区的。上述转换是在timestamp和本地时间做转换。

本地时间是指当前操作系统设定的时区。例如北京时区是东8区，则本地时间：

```
2015-04-19 12:20:00
```

实际上就是UTC+8:00时区的时间：

```
2015-04-19 12:20:00 UTC+8:00
```

而此刻的格林威治标准时间与北京时间差了8小时，也就是UTC+0:00时区的时间应该是：

```
2015-04-19 04:20:00 UTC+0:00
```

timestamp也可以直接被转换到UTC标准时区的时间：

```
>>> from datetime import datetime
>>> t = 1429417200.0
>>> print(datetime.fromtimestamp(t)) # 本地时间
2015-04-19 12:20:00
>>> print(datetime.utcfromtimestamp(t)) # UTC时间
2015-04-19 04:20:00
```

5) .map怎么传多个参数?

用.apply

```
.apply(f,args,kwargs)
```

6) pandas中关于DataFrame的groupby方法，如何取出分组的行名称index和对应分组index的个数

```python
#按A列进行分组，得到分组后的（没有重复行）groupby对象
df_gp = df.groupby("A")

#得到分组的总长度
lenth = len(df_gp.count())

#得到分组后ID(行名称)对应的数量
id_name = df.groupby("A").values

#得到分组后的ID(行名称)
id_num = df.groupby("A").size().index

df.groupby("A").max()
#类似还有 min(), sum()

#取出行id为"11"的组
df_gp.get_group("11")
```

7 )df.groupby("index_name")后.size()跟.count()的区别

size计数时包含NaN值，而count不包含NaN值

8) pandas中关于set_index和reset_index的用法



9) 报错

> TypeError: Only valid with DatetimeIndex, TimedeltaIndex or PeriodIndex, but got an instance of 'Int64Index'

.set_index('date')，以日期为行标签，后面才能进行resample

![image-20200402132830400](https://tva1.sinaimg.cn/large/00831rSTgy1gdhm78smhmj30g507ajs9.jpg)

10) 取出groupby分组中的列层次字段数据

df.groupby(['  ','  ']).unstack(level=1,fill_value=0)

level：如果弄不清level就直接写列名

stack()和unstack函数理解[python pandas stack和unstack函数](https://www.cnblogs.com/bambipai/p/7658311.html)

表格在行列方向上均有索引（类似于DataFrame），花括号结构只有“列方向”上的索引（类似于层次化的Series），结构更加偏向于堆叠（Series-stack，方便记忆）。stack函数会将数据从”表格结构“变成”花括号结构“，即将其行索引变成列索引，反之，unstack函数将数据从”花括号结构“变成”表格结构“，即要将其中一层的列索引变成行索引。



![image-20200402164415154](https://tva1.sinaimg.cn/large/00831rSTgy1gdhm7fpidjj30j20b6t9h.jpg)

11）ValueError: Unstacked DataFrame is too big, causing int32 overflow

这是由于要花括号结构中的数据项太多，不能展开。

12）f.groupby().size() 重新命名新得到的列

怎么得到groupby().size()的结果

比如红框的列





![image-20200403134526724](https://tva1.sinaimg.cn/large/00831rSTgy1gdhm7kd5ycj30bz06twey.jpg)

`f.groupby(["item_id",'user_id']).size().reset_index(name='counts')`

![image-20200403140810332](https://tva1.sinaimg.cn/large/00831rSTgy1gdhm75fc9tj30750ac74q.jpg)

后面就可以正常获取列值了。

13）.value_sort()参数解读

![image-20200402180756750](https://tva1.sinaimg.cn/large/00831rSTgy1gdhm7fcmfqj30nu0fswhg.jpg)

![image-20200402180832685](https://tva1.sinaimg.cn/large/00831rSTgy1gdhm7g6tb3j30ng0bkwgz.jpg)

14）TypeError: unsupported operand type(s) for -: 'Timestamp' and 'str'

需要将日期转换成日期格式

![image-20200402203857486](https://tva1.sinaimg.cn/large/00831rSTgy1gdhm77erhzj30kg07jjs2.jpg)

15）groupby()指定每一列使用某个聚合运算函数

print(df.groupby('key1').agg({'data1':'mean','data2':'sum'}))

item2_table = f.loc[f['behavior_type']=='buy']#筛选出被购买过的商品
item2_table = f.groupby(["item_id",'user_id']).size().reset_index(name='counts')#按商品和客户分组
print("商品复购排行榜:")
item2_table.sort_values('counts',ascending=False)

16）.value_sort()结果得到了inf，想要排除inf的结果怎么办？

方法一：

我最后的解决方案是直接将除数为0的情况排除了，再用 .value_sort()

另外有个参数

![image-20200402180551203](https://tva1.sinaimg.cn/large/00831rSTgy1gdhm74kdcej30jj0ekq5d.jpg)

方法二：

为了不让该值影响到我们，可以考虑将inf全变成NaN，则适用replace进行计算

```python
df.replace([np.inf, -np.inf], np.nan)
```

17）用pandas处理大型csv文件

方法1:分块读取

直接读入很大的文件，会让硬盘和内存飙满且速度非常慢。如果想全部读取但是遇到了MemoryError错误，可以考虑分块读取。

`read_csv()`方法中有一个参数**chunksize**，`chunksize`可以指定一个chunksize分块大小来读取文件，返回一个可迭代的 `TextFileReader` 对象。

nrows参数设置选取文件前多少行，因为数据量太大，如果只想读取有限的行数，可以使用`read_csv()`方法中的`nrows`参数，设定读取的行

usecols参数设定获取文件的规定列

```
table = pd.read_csv('first.csv',nrows=100000,
                     usecols=['column1','column2','column3'], 
                     chunksize=1000,iterator=True)
```

方法2: 指定iterator=True

设定参数`iterator=True`返回一个可迭代的`TextFileReader`对象

```
table= pd.read_table('first.sv', sep='\t', iterator=True)
df=reader.get_chunk(10000)
```

另外，拿到一个很大的CSV文件后，先了解表结构，可以使用.head(n)获取前n行数据或者.tail(n)获取倒数n行数据。

```
df = pd.read_csv('demo.csv')
df.head(10)
#df.tail(10)
```



## 2. jupyter Nodebook 查看函数的帮助

方法1:

在方法后面加问号，然后执行，如f.groupby?

这里f是我赋值的一个变量。查看变量相关：

![image-20200401201234989](https://tva1.sinaimg.cn/large/00831rSTgy1gdhm76x58cj30ja0e776j.jpg)

查看函数参数及函数使用实例：

![image-20200401201049274](https://tva1.sinaimg.cn/large/00831rSTgy1gdhm79sx13j30jd0eaabl.jpg)

方法2：将光标移动到方法上面，按shift+tab，弹出文档，连续按选择文档详细程度

![image-20200401201459803](https://tva1.sinaimg.cn/large/00831rSTgy1gdhm74zchhj30ge037dfy.jpg)

**jupyter notebook卡死问题**

保存后，刷新；实在不行，删除运行中的代码块，运行其他部分；

## 3. 数据可视化

1）python实现漏斗图绘制

2）matplotlib 画饼图

```python
import seaborn as sns
from matplotlib.font_manager import FontProperties
myfont=FontProperties(fname=r'/Users/terese/Downloads/WeiRuanYaHeiTi/WeiRuanYaHei-1.ttf',size=14)
temp = f.groupby("bahavior_type").size()
labels=f.groupby("bahavior_type").size().index
sns.set(font=myfont.get_name())
plt.pie(temp,labels=labels,autopct='%1.2f%%')
plt.title("用户行为比例")
# plt.show()
```

![image-20200401194505662](https://tva1.sinaimg.cn/large/00831rSTgy1gdhm75ya9zj30gi07nmxb.jpg)

3）plot() kind参数表

[plot() kind参数表](http://cloga.info/python/2014/02/23/plotting_with_pandas)

 kind参数——'line', 'bar', 'barh', 'kde':

直方图：plot(kind='bar')

密度图：与直方图相关的一种类型图，是通过计算“可能会产生观测数据的连续概率分布的估计”而产生的，通过给plot传入参数kind = 'kde' 即可。

累积的柱状图：.plot(kind='bar', stacked=True)

![image-20200402013620012](https://tva1.sinaimg.cn/large/00831rSTgy1gdhm7a3ohfj30cc07uq3q.jpg)

相对的累积柱状图：.plot(kind='barh', stacked=True)

![image-20200402013657305](https://tva1.sinaimg.cn/large/00831rSTgy1gdhm79ap6fj30b9076aau.jpg)

散点图：是观测两个一维数据序列之间关系的有效手段，使用pd.scatter_matrix()即可建立。kind='scatter'

4）matplotlib画多条折线图

```python
label=list(bebavior_9day.columns.unique())
print(label)
plt.plot(bebavior_9day,"-H")
plt.gcf().autofmt_xdate()#日期作图需要让横轴的日期倾斜
plt.grid(True)
plt.xlabel("日期")
plt.ylabel("行为量")
plt.title("11.25-12.3用户行为趋势")
plt.legend(label) 
plt.show()
```

![image-20200402141823430](https://tva1.sinaimg.cn/large/00831rSTgy1gdhm780n6wj30oj0fztaj.jpg)

# 